# app.py

import streamlit as st
import requests
import docx
import pandas as pd
from streamlit_quill import st_quill
import io
import json
import re
import zipfile
from googleapiclient.discovery import build
from googleapiclient.http import MediaIoBaseUpload, MediaIoBaseDownload
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
import urllib.parse

# Kh·ªüi t·∫°o session state
if "logged_in" not in st.session_state:
    st.session_state["logged_in"] = False
if "user" not in st.session_state:
    st.session_state["user"] = None
if "role" not in st.session_state:
    st.session_state["role"] = None
if "google_credentials" not in st.session_state:
    st.session_state["google_credentials"] = None
if "uploaded_files" not in st.session_state:
    st.session_state["uploaded_files"] = []
if "grading_results" not in st.session_state:
    st.session_state["grading_results"] = []
if "start_exam" not in st.session_state:
    st.session_state["start_exam"] = False
if "current_num_questions" not in st.session_state:
    st.session_state["current_num_questions"] = 1
if "mssv" not in st.session_state:
    st.session_state["mssv"] = ""
if "full_name" not in st.session_state:
    st.session_state["full_name"] = ""
if "exam_access_granted" not in st.session_state:
    st.session_state["exam_access_granted"] = False

# ·∫®n thanh c√¥ng c·ª• c·ªßa Streamlit
st.markdown(
    """
    <style>
    [data-testid="stToolbar"] {
        visibility: hidden;
    }
    </style>
    """,
    unsafe_allow_html=True
)

# C·∫•u h√¨nh API
API_URL = "https://openrouter.ai/api/v1/chat/completions"
API_KEY = st.secrets["openrouter"]["api_key"]

# C·∫•u h√¨nh Google OAuth
GOOGLE_CLIENT_ID = st.secrets["google_oauth"]["client_id"]
GOOGLE_CLIENT_SECRET = st.secrets["google_oauth"]["client_secret"]
GOOGLE_REDIRECT_URI = st.secrets["google_oauth"]["redirect_uri"]
SCOPES = [
    "https://www.googleapis.com/auth/userinfo.email",
    "https://www.googleapis.com/auth/userinfo.profile",
    "openid"
]

def set_loading_cursor(status):
    """Thay ƒë·ªïi con tr·ªè chu·ªôt khi ƒëang t·∫£i."""
    if status:
        st.markdown(
            """
            <style>
            html, body {
                cursor: wait !important;
            }
            </style>
            """,
            unsafe_allow_html=True
        )
    else:
        st.markdown(
            """
            <style>
            html, body {
                cursor: default !important;
            }
            </style>
            """,
            unsafe_allow_html=True
        )

def clean_markdown_headers(text):
    """Lo·∫°i b·ªè c√°c ti√™u ƒë·ªÅ Markdown t·ª´ vƒÉn b·∫£n."""
    lines = text.split("\n")
    cleaned_lines = [line.replace("### ", "").replace("#### ", "") for line in lines]
    return "\n".join(cleaned_lines)

def authenticate_google_drive():
    """X√°c th·ª±c v√† k·∫øt n·ªëi v·ªõi Google Drive API."""
    SCOPES = ['https://www.googleapis.com/auth/drive']
    creds_info = json.loads(st.secrets["google_drive"]["credentials"])
    creds = Credentials.from_authorized_user_info(info=creds_info, scopes=SCOPES)
    if creds and creds.expired and creds.refresh_token:
        creds.refresh(Request())
    return build('drive', 'v3', credentials=creds)

def get_or_create_folder(service, folder_name, parent_id=None):
    """T√¨m ho·∫∑c t·∫°o m·ªôt th∆∞ m·ª•c tr√™n Google Drive."""
    query = f"name='{folder_name}' and mimeType='application/vnd.google-apps.folder' and trashed=false"
    if parent_id:
        query += f" and '{parent_id}' in parents"
    response = service.files().list(q=query, spaces='drive').execute()
    folders = response.get('files', [])
    if folders:
        return folders[0]['id']
    folder_metadata = {
        'name': folder_name,
        'mimeType': 'application/vnd.google-apps.folder'
    }
    if parent_id:
        folder_metadata['parents'] = [parent_id]
    folder = service.files().create(body=folder_metadata, fields='id').execute()
    return folder['id']

def clear_folder(service, folder_id):
    """X√≥a t·∫•t c·∫£ file trong m·ªôt th∆∞ m·ª•c tr√™n Google Drive."""
    response = service.files().list(q=f"'{folder_id}' in parents and trashed=false", spaces='drive').execute()
    for file in response.get('files', []):
        service.files().delete(fileId=file['id']).execute()

def upload_file_to_drive(service, file_content, file_name, folder_id, update_if_exists=True):
    """T·∫£i file l√™n Google Drive."""
    base_name = file_name.replace("_graded.docx", "")
    query = f"'{folder_id}' in parents and trashed=false"
    response = service.files().list(q=query, spaces='drive').execute()
    for file in response.get('files', []):
        if file['name'].startswith(base_name) and update_if_exists:
            service.files().delete(fileId=file['id']).execute()
    file_metadata = {
        'name': file_name,
        'parents': [folder_id]
    }
    media = MediaIoBaseUpload(io.BytesIO(file_content), mimetype='application/octet-stream')
    file = service.files().create(body=file_metadata, media_body=media, fields='id').execute()
    permission = {
        'type': 'anyone',
        'role': 'reader'
    }
    service.permissions().create(fileId=file['id'], body=permission).execute()
    return file['id']

def download_file_from_drive(service, file_id):
    """T·∫£i file t·ª´ Google Drive."""
    request = service.files().get_media(fileId=file_id)
    file_content = io.BytesIO()
    downloader = MediaIoBaseDownload(file_content, request)
    done = False
    while not done:
        status, done = downloader.next_chunk()
    file_content.seek(0)
    return file_content.read()

def find_file_in_folder(service, file_name, folder_id):
    """T√¨m file trong m·ªôt th∆∞ m·ª•c tr√™n Google Drive."""
    query = f"name='{file_name}' and '{folder_id}' in parents and trashed=false"
    response = service.files().list(q=query, spaces='drive').execute()
    files = response.get('files', [])
    return files[0] if files else None

def get_exam_list(service, exams_folder_id):
    """L·∫•y danh s√°ch ƒë·ªÅ thi t·ª´ Google Drive."""
    exam_secrets_file = find_file_in_folder(service, "exam_secrets.json", exams_folder_id)
    if exam_secrets_file:
        content = download_file_from_drive(service, exam_secrets_file['id'])
        return json.loads(content.decode('utf-8'))
    return []

def update_exam_list(service, exams_folder_id, exam_list):
    """C·∫≠p nh·∫≠t danh s√°ch ƒë·ªÅ thi l√™n Google Drive."""
    json_content = json.dumps(exam_list, ensure_ascii=False, indent=4)
    upload_file_to_drive(service, json_content.encode('utf-8'), "exam_secrets.json", exams_folder_id, update_if_exists=True)

# Kh·ªüi t·∫°o service v√† root folder
service = authenticate_google_drive()
root_folder_id = get_or_create_folder(service, "ExamSystem")

def initialize_teacher_folders(service, username):
    """Kh·ªüi t·∫°o c√°c th∆∞ m·ª•c cho gi√°o vi√™n tr√™n Google Drive."""
    teacher_folder = get_or_create_folder(service, f"teacher_{username}", root_folder_id)
    exams_folder = get_or_create_folder(service, "exams", teacher_folder)
    essays_folder = get_or_create_folder(service, "essays", teacher_folder)
    graded_essays_folder_id = get_or_create_folder(service, "graded_essays", teacher_folder)
    reports_folder_id = get_or_create_folder(service, "reports", teacher_folder)
    return {
        "teacher_folder_id": teacher_folder,
        "exams_folder_id": exams_folder,
        "essays_folder_id": essays_folder,
        "graded_essays_folder_id": graded_essays_folder_id,
        "reports_folder_id": reports_folder_id
    }

def get_google_auth_url():
    """T·∫°o URL ƒë·ªÉ ng∆∞·ªùi d√πng ƒëƒÉng nh·∫≠p b·∫±ng Google."""
    flow = InstalledAppFlow.from_client_config(
        {
            "web": {
                "client_id": GOOGLE_CLIENT_ID,
                "client_secret": GOOGLE_CLIENT_SECRET,
                "redirect_uris": [GOOGLE_REDIRECT_URI],
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token"
            }
        },
        scopes=SCOPES
    )
    flow.redirect_uri = GOOGLE_REDIRECT_URI
    auth_url, _ = flow.authorization_url(prompt='consent', access_type='offline')
    return auth_url

def handle_google_callback(code):
    """X·ª≠ l√Ω callback t·ª´ Google sau khi ng∆∞·ªùi d√πng ƒëƒÉng nh·∫≠p."""
    flow = InstalledAppFlow.from_client_config(
        {
            "web": {
                "client_id": GOOGLE_CLIENT_ID,
                "client_secret": GOOGLE_CLIENT_SECRET,
                "redirect_uris": [GOOGLE_REDIRECT_URI],
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token"
            }
        },
        scopes=SCOPES
    )
    flow.redirect_uri = GOOGLE_REDIRECT_URI
    flow.fetch_token(code=code)
    credentials = flow.credentials
    return credentials

def get_user_info(credentials):
    """L·∫•y th√¥ng tin ng∆∞·ªùi d√πng t·ª´ Google."""
    oauth2_client = build('oauth2', 'v2', credentials=credentials)
    user_info = oauth2_client.userinfo().get().execute()
    return user_info

def login_with_google():
    st.session_state["logged_in"] = False
    st.markdown("<h2 style='text-align: center; font-size: 36px;'>üë§ƒêƒÉng nh·∫≠p h·ªá th·ªëng</h2>", unsafe_allow_html=True)

    auth_url = get_google_auth_url()
    st.markdown(f'<a href="{auth_url}" target="_self"><button>ƒêƒÉng nh·∫≠p b·∫±ng Google</button></a>', unsafe_allow_html=True)

    query_params = st.query_params
    code = query_params.get("code")
    if code:
        try:
            credentials = handle_google_callback(code)
            st.session_state["google_credentials"] = credentials
            user_info = get_user_info(credentials)
            email = user_info.get("email")
            name = user_info.get("name", email.split("@")[0])

            if email.endswith("@ntt.edu.vn"):
                role = "teacher"
            else:
                role = "student"

            st.session_state["logged_in"] = True
            st.session_state["user"] = name
            st.session_state["role"] = role
            st.session_state["email"] = email

            st.success(f"Xin ch√†o, {name} ({role})!")
            st.rerun()
        except Exception as e:
            st.error(f"ƒêƒÉng nh·∫≠p th·∫•t b·∫°i: {str(e)}")
            st.write("Query parameters:", query_params)  # Debug info

def logout():
    """X·ª≠ l√Ω ƒëƒÉng xu·∫•t ng∆∞·ªùi d√πng."""
    st.session_state.clear()
    st.rerun()

def read_docx(file_content):
    """ƒê·ªçc n·ªôi dung file DOCX."""
    doc = docx.Document(io.BytesIO(file_content))
    return "\n".join([para.text for para in doc.paragraphs])

def save_to_csv(data, service, folder_id):
    """L∆∞u d·ªØ li·ªáu v√†o file CSV tr√™n Google Drive."""
    df = pd.DataFrame(data)
    csv_buffer = io.StringIO()
    df.to_csv(csv_buffer, index=False, encoding='utf-8-sig')
    existing_file = find_file_in_folder(service, "grading_report.csv", folder_id)
    if existing_file:
        existing_content = download_file_from_drive(service, existing_file['id'])
        existing_df = pd.read_csv(io.StringIO(existing_content.decode('utf-8-sig')), encoding='utf-8-sig')
        df = pd.concat([existing_df, df], ignore_index=True)
        df.to_csv(csv_buffer, index=False, encoding='utf-8-sig')
        file_metadata = {'name': "grading_report.csv"}
        media = MediaIoBaseUpload(io.BytesIO(csv_buffer.getvalue().encode('utf-8')), mimetype='text/csv')
        service.files().update(fileId=existing_file['id'], body=file_metadata, media_body=media).execute()
    else:
        df.to_csv(csv_buffer, index=False, encoding='utf-8-sig')
        upload_file_to_drive(service, csv_buffer.getvalue().encode('utf-8'), "grading_report.csv", folder_id)

def extract_key_points_and_keywords(answer_text):
    """
    H√†m ph√¢n t√≠ch ƒë√°p √°n m·∫´u ƒë·ªÉ tr√≠ch xu·∫•t c√°c √Ω ch√≠nh v√† t·ª´ kh√≥a (keywords) nh·∫±m ch·∫•m ƒëi·ªÉm b√†i t·ª± lu·∫≠n.
    
    Args:
        answer_text (str): ƒê√°p √°n m·∫´u d∆∞·ªõi d·∫°ng vƒÉn b·∫£n.
    
    Returns:
        dict: M·ªôt dictionary ch·ª©a c√°c √Ω ch√≠nh, t·ª´ kh√≥a t√≠ch c·ª±c/ti√™u c·ª±c v√† quy t·∫Øc ng·ªØ c·∫£nh (n·∫øu c√≥).
              Tr·∫£ v·ªÅ None n·∫øu c√≥ l·ªói x·∫£y ra.
    """
    # Ki·ªÉm tra ƒë·∫ßu v√†o
    if not answer_text or not answer_text.strip():
        print("Error: answer_text is empty or invalid")
        return None

    # T·∫°o prompt b·∫±ng c√°ch chia th√†nh c√°c ph·∫ßn nh·ªè
    prompt_parts = [
        "B·∫°n l√† m·ªôt tr·ª£ l√Ω AI chuy√™n ph√¢n t√≠ch ƒë√°p √°n m·∫´u. D·ª±a tr√™n ƒëo·∫°n vƒÉn b·∫£n sau, ",
        "h√£y ph√¢n t√≠ch th√†nh c√°c √Ω ch√≠nh (key points) v√† tr√≠ch xu·∫•t t·ª´ kh√≥a ƒë·ªÉ s·ª≠ d·ª•ng trong vi·ªác ch·∫•m ƒëi·ªÉm b√†i t·ª± lu·∫≠n.\n\n",
        
        f"**ƒê√°p √°n m·∫´u:**\n{answer_text}\n\n",
        
        "**Y√™u c·∫ßu:**\n",
        "1. Ph√¢n t√≠ch ƒë√°p √°n m·∫´u th√†nh c√°c √Ω ch√≠nh (key points), m·ªói √Ω ch√≠nh c√≥ tr·ªçng s·ªë (t·ªïng tr·ªçng s·ªë = 1).\n",
        "2. Tr√≠ch xu·∫•t t·ª´ kh√≥a t√≠ch c·ª±c (positive keywords) v√† t·ª´ kh√≥a ti√™u c·ª±c (negative keywords) cho t·ª´ng √Ω ch√≠nh.\n",
        "3. Th√™m quy t·∫Øc ng·ªØ c·∫£nh (contextual rules) n·∫øu c·∫ßn (v√≠ d·ª•: m·ªôt s·ªë t·ª´ kh√≥a ch·ªâ c√≥ √Ω nghƒ©a khi xu·∫•t hi·ªán c√πng nhau).\n",
        "4. Tr·∫£ v·ªÅ k·∫øt qu·∫£ d∆∞·ªõi d·∫°ng JSON v·ªõi c·∫•u tr√∫c:\n",
        "   ```json\n",
        "   {\n",
        '       "√ù 1": {\n',
        '           "description": "M√¥ t·∫£ √Ω ch√≠nh",\n',
        '           "weight": 0.3,\n',
        '           "positive_keywords": [\n',
        '               {"keyword": "t·ª´ kh√≥a 1", "weight": 0.5},\n',
        '               {"keyword": "t·ª´ kh√≥a 2", "weight": 0.3},\n',
        "               ...\n",
        "           ],\n",
        '           "negative_keywords": [\n',
        '               {"keyword": "t·ª´ kh√≥a sai 1", "weight": -0.2},\n',
        "               ...\n",
        "           ],\n",
        '           "contextual_rule": "Quy t·∫Øc ng·ªØ c·∫£nh (n·∫øu c√≥)"\n',
        "       },\n",
        '       "√ù 2": { ... }\n',
        "   }\n",
        "   ```\n\n",
        
        "B·∫Øt ƒë·∫ßu ph√¢n t√≠ch:"
    ]
    
    # N·ªëi c√°c ph·∫ßn c·ªßa prompt l·∫°i
    prompt = "".join(prompt_parts)

    # C·∫•u h√¨nh headers cho API request
    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }
    
    # C·∫•u h√¨nh payload (d·ªØ li·ªáu g·ª≠i ƒëi) cho API
    data = {
        "model": "mistralai/mistral-small-3.1-24b-instruct:free",
        "messages": [
            {"role": "system", "content": "B·∫°n l√† m·ªôt tr·ª£ l√Ω AI chuy√™n ph√¢n t√≠ch ƒë√°p √°n m·∫´u."},
            {"role": "user", "content": prompt}
        ],
        "temperature": 0.3
    }
    
    # G·ª≠i y√™u c·∫ßu ƒë·∫øn API v√† x·ª≠ l√Ω k·∫øt qu·∫£
    try:
        response = requests.post(API_URL, headers=headers, json=data, timeout=30)
        if response.status_code == 200:
            result = response.json()["choices"][0]["message"]["content"]
            return json.loads(result)
        else:
            print(f"API request failed with status code: {response.status_code}")
            return None
    except requests.exceptions.RequestException as e:
        print(f"Error during API request: {e}")
        return None
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON response: {e}")
        return None

def grade_essay(student_text, answer_text, student_name=None, mssv=None, key_points=None):
    """
    H√†m ch·∫•m ƒëi·ªÉm b√†i t·ª± lu·∫≠n c·ªßa sinh vi√™n d·ª±a tr√™n ƒë√°p √°n m·∫´u.
    
    Args:
        student_text (str): B√†i l√†m c·ªßa sinh vi√™n.
        answer_text (str): ƒê√°p √°n m·∫´u.
        student_name (str, optional): T√™n sinh vi√™n.
        mssv (str, optional): M√£ s·ªë sinh vi√™n.
        key_points (dict, optional): Danh s√°ch √Ω ch√≠nh v√† t·ª´ kh√≥a.
    
    Returns:
        str: K·∫øt qu·∫£ ch·∫•m ƒëi·ªÉm d∆∞·ªõi d·∫°ng vƒÉn b·∫£n. Tr·∫£ v·ªÅ None n·∫øu c√≥ l·ªói.
    """
    # N·∫øu key_points ch∆∞a c√≥, ph√¢n t√≠ch ƒë√°p √°n m·∫´u ƒë·ªÉ l·∫•y key_points
    if key_points is None:
        set_loading_cursor(True)
        with st.spinner("ƒêang ph√¢n t√≠ch ƒë√°p √°n m·∫´u..."):
            key_points = extract_key_points_and_keywords(answer_text)
        set_loading_cursor(False)
        if not key_points:
            return None

    # T·∫°o prompt b·∫±ng c√°ch chia th√†nh c√°c ph·∫ßn nh·ªè
    prompt_parts = [
        "B·∫°n l√† m·ªôt gi·∫£ng vi√™n ch·∫•m b√†i chuy√™n nghi·ªáp. H√£y ch·∫•m b√†i t·ª± lu·∫≠n sau ƒë√¢y b·∫±ng c√°ch so s√°nh b√†i l√†m c·ªßa sinh vi√™n v·ªõi ƒë√°p √°n m·∫´u.\n\n",
        
        f"**ƒê√°p √°n m·∫´u:**\n{answer_text}\n\n",
        
        f"**B√†i l√†m c·ªßa sinh vi√™n:**\n{student_text}\n\n",
        
        "**Danh s√°ch √Ω ch√≠nh v√† t·ª´ kh√≥a:**\n",
        "D∆∞·ªõi ƒë√¢y l√† danh s√°ch c√°c √Ω ch√≠nh (key points) v√† t·ª´ kh√≥a (keywords) ƒë·ªÉ b·∫°n ƒë√°nh gi√° b√†i l√†m. ",
        "S·ª≠ d·ª•ng c√°c √Ω ch√≠nh v√† t·ª´ kh√≥a n√†y ƒë·ªÉ x√°c ƒë·ªãnh m·ª©c ƒë·ªô ph√π h·ª£p c·ªßa b√†i l√†m v·ªõi ƒë√°p √°n m·∫´u.\n\n"
    ]
    
    # Th√™m th√¥ng tin v·ªÅ c√°c √Ω ch√≠nh v√† t·ª´ kh√≥a v√†o prompt
    for point, data in key_points.items():
        prompt_parts.append(f"**{point} (tr·ªçng s·ªë: {data['weight']}):** {data['description']}\n")
        prompt_parts.append("T·ª´ kh√≥a t√≠ch c·ª±c (positive keywords):\n")
        for kw in data["positive_keywords"]:
            prompt_parts.append(f"- '{kw['keyword']}' (tr·ªçng s·ªë: {kw['weight']})\n")
        prompt_parts.append("T·ª´ kh√≥a ti√™u c·ª±c (negative keywords):\n")
        for kw in data.get("negative_keywords", []):
            prompt_parts.append(f"- '{kw['keyword']}' (tr·ªçng s·ªë: {kw['weight']})\n")
        if "contextual_rule" in data:
            prompt_parts.append(f"Quy t·∫Øc ng·ªØ c·∫£nh: {data['contextual_rule']}\n")
    
    # Th√™m y√™u c·∫ßu ch·∫•m b√†i v√† v√≠ d·ª• ƒë·ªãnh d·∫°ng k·∫øt qu·∫£
    prompt_parts.extend([
        "\n**Y√™u c·∫ßu ch·∫•m b√†i:**\n",
        "1. ƒê∆∞a ra nh·∫≠n x√©t chi ti·∫øt v·ªÅ b√†i l√†m c·ªßa sinh vi√™n:\n",
        "   - Ki·ªÉm tra xem b√†i l√†m c√≥ ch·ª©a c√°c √Ω ch√≠nh kh√¥ng (d·ª±a tr√™n t·ª´ kh√≥a t√≠ch c·ª±c).\n",
        "   - Tr·ª´ ƒëi·ªÉm n·∫øu b√†i l√†m ch·ª©a t·ª´ kh√≥a ti√™u c·ª±c.\n",
        "   - ƒê√°nh gi√° m·ª©c ƒë·ªô chi ti·∫øt, t√≠nh ch√≠nh x√°c, v√† v√≠ d·ª• minh h·ªça (n·∫øu c√≥).\n",
        "2. Ch·∫•m ƒëi·ªÉm tr√™n thang 10, t√≠nh ƒëi·ªÉm d·ª±a tr√™n tr·ªçng s·ªë c·ªßa √Ω ch√≠nh v√† t·ª´ kh√≥a:\n",
        "   - N·∫øu √Ω ch√≠nh ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p ƒë·∫ßy ƒë·ªß (c√≥ t·ª´ kh√≥a t√≠ch c·ª±c), c·ªông ƒëi·ªÉm theo tr·ªçng s·ªë.\n",
        "   - N·∫øu √Ω ch√≠nh thi·∫øu ho·∫∑c c√≥ t·ª´ kh√≥a ti√™u c·ª±c, tr·ª´ ƒëi·ªÉm.\n",
        "3. Ghi r√µ t·ªïng ƒëi·ªÉm c·ªßa b√†i l√†m theo ƒë·ªãnh d·∫°ng: **T·ªïng ƒëi·ªÉm: [s·ªë ƒëi·ªÉm]** (d√≤ng cu·ªëi c√πng).\n\n",
        
        "**V√≠ d·ª• ƒë·ªãnh d·∫°ng k·∫øt qu·∫£:**\n",
        "Nh·∫≠n x√©t chi ti·∫øt v·ªÅ b√†i l√†m c·ªßa sinh vi√™n:\n\n",
        "**√ù 1:**\n",
        "- Sinh vi√™n gi·∫£i th√≠ch ƒë√∫ng kh√°i ni·ªám.\n",
        "- ƒêi·ªÉm tr·ª´: Thi·∫øu v√≠ d·ª• b·ªï sung.\n\n",
        "**√ù 2:**\n",
        "- Sinh vi√™n m√¥ t·∫£ ƒë√∫ng m·ªôt ph·∫ßn.\n",
        "- ƒêi·ªÉm tr·ª´: Thi·∫øu gi·∫£i th√≠ch chi ti·∫øt.\n\n",
        "ƒêi·ªÉm:\n",
        "- √ù 1: **7.0**\n",
        "- √ù 2: **5.5**\n\n",
        "**T·ªïng ƒëi·ªÉm: 6.0**\n\n",
        
        "B·∫Øt ƒë·∫ßu ch·∫•m b√†i:"
    ])
    
    # N·ªëi c√°c ph·∫ßn c·ªßa prompt l·∫°i
    prompt = "".join(prompt_parts)

    # C·∫•u h√¨nh headers cho API request
    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }
    
    # C·∫•u h√¨nh payload (d·ªØ li·ªáu g·ª≠i ƒëi) cho API
    data = {
        "model": "mistralai/mistral-small-3.1-24b-instruct:free",
        "messages": [
            {"role": "system", "content": "B·∫°n l√† m·ªôt gi·∫£ng vi√™n ch·∫•m b√†i chuy√™n nghi·ªáp."},
            {"role": "user", "content": prompt}
        ],
        "temperature": 0.3
    }
    
    # G·ª≠i y√™u c·∫ßu ƒë·∫øn API v√† x·ª≠ l√Ω k·∫øt qu·∫£
    try:
        response = requests.post(API_URL, headers=headers, json=data, timeout=30)
        if response.status_code == 200:
            grading_result = response.json()["choices"][0]["message"]["content"]
            if student_name and mssv:
                total_score = extract_score(grading_result)
                data = {
                    "MSSV": [mssv],
                    "H·ªç v√† T√™n": [student_name],
                    "ƒêi·ªÉm T·ªïng": [total_score],
                    "K·∫øt qu·∫£ ch·∫•m ƒëi·ªÉm": [grading_result]
                }
                save_to_csv(data, service, reports_folder_id)
            return grading_result
        else:
            print(f"API request failed with status code: {response.status_code}")
            return None
    except requests.exceptions.RequestException as e:
        print(f"Error during API request: {e}")
        return None

def extract_score(grading_result):
    """Tr√≠ch xu·∫•t ƒëi·ªÉm s·ªë t·ª´ k·∫øt qu·∫£ ch·∫•m ƒëi·ªÉm."""
    matches = re.findall(r"T·ªïng ƒëi·ªÉm:\s*(\d+(\.\d+)?)", grading_result, re.IGNORECASE)
    if matches:
        return float(matches[-1][0])
    matches = re.findall(r"ƒêi·ªÉm:\s*(\d+(\.\d+)?)", grading_result, re.IGNORECASE)
    if matches:
        return float(matches[-1][0])
    matches = re.findall(r"ƒêi·ªÉm:\s*(\d+(\.\d+)?)/\d+", grading_result, re.IGNORECASE)
    if matches:
        return float(matches[-1][0])
    matches = re.findall(r"Score:\s*(\d+(\.\d+)?)", grading_result, re.IGNORECASE)
    if matches:
        return float(matches[-1][0])
    matches = re.findall(r"(\d+(\.\d+)?)/10", grading_result)
    if matches:
        return float(matches[-1][0])
    matches = re.findall(r"^\s*(\d+(\.\d+)?)\s*$", grading_result, re.MULTILINE)
    if matches:
        return float(matches[-1][0])
    return 0.0

def load_grading_report(service, folder_id):
    """T·∫£i b√°o c√°o ch·∫•m ƒëi·ªÉm t·ª´ Google Drive."""
    file = find_file_in_folder(service, "grading_report.csv", folder_id)
    if file:
        content = download_file_from_drive(service, file['id'])
        return pd.read_csv(io.StringIO(content.decode('utf-8-sig')), encoding='utf-8-sig')
    return None

# Logic ch√≠nh c·ªßa ·ª©ng d·ª•ng
if not st.session_state["logged_in"]:
    login_with_google()
else:
    role = st.session_state.get("role", "student")
    if role == "student":
        st.markdown("<h1 style='text-align: center; font-size: 40px;'>H·ªá th·ªëng thi t·ª± lu·∫≠n tr·ª±c tuy·∫øn NTTU</h1>", unsafe_allow_html=True)
    else:
        st.markdown("<h1 style='text-align: center; font-size: 40px;'>üéìH·ªá th·ªëng ch·∫•m t·ª± lu·∫≠n b·∫±ng AI</h1>", unsafe_allow_html=True)
    
    st.write(f"Xin ch√†o, {st.session_state['user']} ({st.session_state['role']})!")
    if st.button("ƒêƒÉng xu·∫•t"):
        logout()
    
    if role == "teacher":
        teacher_folders = initialize_teacher_folders(service, st.session_state["email"])
        exams_folder_id = teacher_folders["exams_folder_id"]
        essays_folder_id = teacher_folders["essays_folder_id"]
        graded_essays_folder_id = teacher_folders["graded_essays_folder_id"]
        reports_folder_id = teacher_folders["reports_folder_id"]
        
        st.subheader("T·∫£i ƒë·ªÅ thi v√† ƒë√°p √°n")
        exam_list = get_exam_list(service, exams_folder_id)
        if exam_list:
            st.info("Danh s√°ch ƒë·ªÅ thi hi·ªán c√≥:")
            for exam in exam_list:
                subject_code = exam.get("subject_code", "N/A")
                term = exam.get("term", "N/A")
                subject_name = exam.get("subject_name", "N/A")
                st.write(f"- {subject_code} - {term} - {subject_name} - {exam['exam_file']} (M√£ s·ªë b√≠ m·∫≠t: {exam['secret_code']})")
        
        col1, col2 = st.columns(2)
        with col1:
            if exam_list and st.button("X√≥a t·∫•t c·∫£ ƒë·ªÅ thi"):
                for exam in exam_list:
                    service.files().delete(fileId=exam['exam_id']).execute()
                    service.files().delete(fileId=exam['answer_id']).execute()
                exam_secrets_file = find_file_in_folder(service, "exam_secrets.json", exams_folder_id)
                if exam_secrets_file:
                    service.files().delete(fileId=exam_secrets_file['id']).execute()
                st.success("ƒê√£ x√≥a t·∫•t c·∫£ ƒë·ªÅ thi v√† ƒë√°p √°n.")
                st.rerun()
        
        st.subheader("T·∫£i l√™n ƒë·ªÅ thi m·ªõi")
        uploaded_exam_pdf = st.file_uploader("T·∫£i l√™n ƒë·ªÅ thi (PDF)", type=["pdf"], key="exam_pdf")
        uploaded_answer = st.file_uploader("T·∫£i l√™n ƒë√°p √°n m·∫´u", type=["docx"], key="answer")
        subject_code = st.text_input("M√£ h·ªçc ph·∫ßn (v√≠ d·ª•: IT001):", key="subject_code")
        term = st.text_input("T√™n l·ªõn (v√≠ d·ª•: K·ª≥ 1 - 2024):", key="term")
        subject_name = st.text_input("T√™n m√¥n h·ªçc (v√≠ d·ª•: L·∫≠p tr√¨nh Python):", key="subject_name")
        secret_code = st.text_input("Nh·∫≠p m√£ s·ªë b√≠ m·∫≠t cho ƒë·ªÅ thi:", type="password", key="secret_code")
        
        if st.button("T·∫£i l√™n ƒë·ªÅ thi"):
            if not uploaded_exam_pdf or not uploaded_answer:
                st.error("Vui l√≤ng t·∫£i l√™n c·∫£ file ƒë·ªÅ thi (PDF) v√† ƒë√°p √°n m·∫´u (DOCX).")
            elif not subject_code or not term or not subject_name or not secret_code:
                st.error("Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß M√£ h·ªçc ph·∫ßn, T√™n l·ªõn, T√™n m√¥n h·ªçc v√† M√£ s·ªë b√≠ m·∫≠t.")
            else:
                exam_pdf_content = uploaded_exam_pdf.read()
                answer_content = uploaded_answer.read()
                exam_count = len(exam_list) + 1
                exam_filename = f"de_thi_{exam_count}.pdf"
                answer_filename = f"dap_an_{exam_count}.docx"
                exam_file_id = upload_file_to_drive(service, exam_pdf_content, exam_filename, exams_folder_id, update_if_exists=True)
                answer_file_id = upload_file_to_drive(service, answer_content, answer_filename, exams_folder_id, update_if_exists=True)
                exam_list.append({
                    "exam_file": exam_filename,
                    "exam_id": exam_file_id,
                    "answer_file": answer_filename,
                    "answer_id": answer_file_id,
                    "secret_code": secret_code,
                    "subject_code": subject_code,
                    "term": term,
                    "subject_name": subject_name
                })
                update_exam_list(service, exams_folder_id, exam_list)
                st.success(f"ƒê·ªÅ thi {exam_filename} v√† ƒë√°p √°n ƒë√£ ƒë∆∞·ª£c l∆∞u tr√™n Google Drive.")
                st.rerun()

        tab1, tab2, tab3 = st.tabs(["Ch·∫•m b√†i ƒë∆°n", "Ch·∫•m b√†i h√†ng lo·∫°t", "Xem b√°o c√°o"])

        with tab1:
            uploaded_essay = st.file_uploader("T·∫£i l√™n b√†i l√†m t·ª± lu·∫≠n c·ªßa sinh vi√™n", type=["docx"], key="single_essay")
            if uploaded_essay:
                exam_list = get_exam_list(service, exams_folder_id)
                if exam_list:
                    display_names = [f"{exam['subject_code']} - {exam['term']} - {exam['subject_name']}" for exam in exam_list]
                    selected_display_name = st.selectbox("Ch·ªçn ƒë√°p √°n m·∫´u:", display_names, key="select_exam_single")
                    selected_exam = next(exam for exam in exam_list 
                                       if f"{exam['subject_code']} - {exam['term']} - {exam['subject_name']}" == selected_display_name)
                    answer_content = download_file_from_drive(service, selected_exam['answer_id'])
                    answer_text = read_docx(answer_content)
                    filename = uploaded_essay.name
                    try:
                        mssv, student_name = filename.replace(".docx", "").split("_", 1)
                    except ValueError:
                        st.error("T√™n file kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng 'MSSV_H·ªçT√™n.docx'. Vui l√≤ng ki·ªÉm tra l·∫°i.")
                    else:
                        student_text = read_docx(uploaded_essay.read())
                        set_loading_cursor(True)
                        with st.spinner("ƒêang ch·∫•m b√†i..."):
                            result = grade_essay(student_text, answer_text, student_name, mssv)
                        set_loading_cursor(False)
                        if result:
                            st.subheader("K·∫øt qu·∫£ ch·∫•m ƒëi·ªÉm:")
                            st.write(f"MSSV: {mssv}")
                            st.write(f"H·ªç v√† T√™n: {student_name}")
                            st.write(result)
                            cleaned_result = clean_markdown_headers(result)
                            graded_filename = f"{mssv}_{student_name}_graded.docx"
                            doc = docx.Document()
                            doc.add_paragraph(f"MSSV: {mssv}")
                            doc.add_paragraph(f"H·ªç v√† T√™n: {student_name}")
                            doc.add_paragraph(cleaned_result)
                            doc_buffer = io.BytesIO()
                            doc.save(doc_buffer)
                            doc_buffer.seek(0)
                            upload_file_to_drive(service, doc_buffer.getvalue(), graded_filename, graded_essays_folder_id)
                            st.success(f"K·∫øt qu·∫£ ƒë√£ ƒë∆∞·ª£c l∆∞u tr√™n Google Drive v·ªõi t√™n: {graded_filename}")
                            st.download_button(
                                label="T·∫£i k·∫øt qu·∫£ ch·∫•m ƒëi·ªÉm",
                                data=doc_buffer.getvalue(),
                                file_name=graded_filename,
                                mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                            )
                else:
                    st.error("Kh√¥ng t√¨m th·∫•y ƒë√°p √°n m·∫´u tr√™n Google Drive. Vui l√≤ng t·∫£i l√™n ƒë√°p √°n tr∆∞·ªõc.")

        with tab2:
            if "start_grading" not in st.session_state:
                st.session_state["start_grading"] = False
            uploaded_essays = st.file_uploader("T·∫£i l√™n nhi·ªÅu b√†i l√†m t·ª± lu·∫≠n", type=["docx"], accept_multiple_files=True, key="batch_essays")
            MAX_FILES = 10
            if uploaded_essays and len(uploaded_essays) > MAX_FILES:
                st.error(f"Vui l√≤ng ch·ªâ t·∫£i l√™n t·ªëi ƒëa {MAX_FILES} file ƒë·ªÉ ch·∫•m h√†ng lo·∫°t.")
                uploaded_essays = uploaded_essays[:MAX_FILES]
            current_files = [file.name for file in uploaded_essays] if uploaded_essays else []
            if current_files != st.session_state["uploaded_files"]:
                st.session_state["uploaded_files"] = current_files
                st.session_state["grading_results"] = []
                st.session_state["start_grading"] = False
            if uploaded_essays:
                exam_list = get_exam_list(service, exams_folder_id)
                if exam_list:
                    display_names = [f"{exam['subject_code']} - {exam['term']} - {exam['subject_name']}" for exam in exam_list]
                    selected_display_name = st.selectbox("Ch·ªçn ƒë√°p √°n m·∫´u:", display_names, key="select_exam_batch")
                    if st.button("Ch·∫•m b√†i"):
                        st.session_state["start_grading"] = True
                        st.session_state["grading_results"] = []
                        set_loading_cursor(True)
                        with st.spinner("ƒêang x√≥a c√°c file k·∫øt qu·∫£ c≈©..."):
                            clear_folder(service, graded_essays_folder_id)
                        set_loading_cursor(False)
                        selected_exam = next(exam for exam in exam_list 
                                           if f"{exam['subject_code']} - {exam['term']} - {exam['subject_name']}" == selected_display_name)
                        answer_content = download_file_from_drive(service, selected_exam['answer_id'])
                        answer_text = read_docx(answer_content)
                        results = []
                        set_loading_cursor(True)
                        with st.spinner("ƒêang ch·∫•m b√†i h√†ng lo·∫°t..."):
                            for idx, essay_file in enumerate(uploaded_essays, 1):
                                filename = essay_file.name
                                try:
                                    mssv, student_name = filename.replace(".docx", "").split("_", 1)
                                except ValueError:
                                    st.warning(f"T√™n file {filename} kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng 'MSSV_H·ªçT√™n.docx'. B·ªè qua.")
                                    continue
                                student_text = read_docx(essay_file.read())
                                grading_result = grade_essay(student_text, answer_text, student_name, mssv)
                                if grading_result:
                                    total_score = extract_score(grading_result)
                                    results.append({
                                        "STT": idx,
                                        "MSSV": mssv,
                                        "H·ªç v√† T√™n": student_name,
                                        "T·ªïng ƒëi·ªÉm t·ª± lu·∫≠n": total_score
                                    })
                                    cleaned_result = clean_markdown_headers(grading_result)
                                    graded_filename = f"{mssv}_{student_name}_graded.docx"
                                    doc = docx.Document()
                                    doc.add_paragraph(f"MSSV: {mssv}")
                                    doc.add_paragraph(f"H·ªç v√† T√™n: {student_name}")
                                    doc.add_paragraph(cleaned_result)
                                    doc_buffer = io.BytesIO()
                                    doc.save(doc_buffer)
                                    doc_buffer.seek(0)
                                    upload_file_to_drive(service, doc_buffer.getvalue(), graded_filename, graded_essays_folder_id)
                        set_loading_cursor(False)
                        st.session_state["grading_results"] = results
                else:
                    st.error("Kh√¥ng t√¨m th·∫•y ƒë√°p √°n m·∫´u tr√™n Google Drive. Vui l√≤ng t·∫£i l√™n ƒë√°p √°n tr∆∞·ªõc.")
            if st.session_state["grading_results"]:
                df = pd.DataFrame(st.session_state["grading_results"])
                st.subheader("K·∫øt qu·∫£ ch·∫•m ƒëi·ªÉm h√†ng lo·∫°t:")
                st.dataframe(df)
                csv_buffer = io.StringIO()
                df.to_csv(csv_buffer, index=False, encoding='utf-8-sig')
                csv = csv_buffer.getvalue().encode('utf-8')
                st.download_button(
                    label="T·∫£i b√°o c√°o CSV",
                    data=csv,
                    file_name="batch_grading_report.csv",
                    mime="text/csv"
                )
                st.success("ƒê√£ ch·∫•m xong t·∫•t c·∫£ b√†i v√† l∆∞u k·∫øt qu·∫£ tr√™n Google Drive.")
                st.subheader("T·∫£i k·∫øt qu·∫£ chi ti·∫øt cho sinh vi√™n:")
                response = service.files().list(q=f"'{graded_essays_folder_id}' in parents and trashed=false", spaces='drive').execute()
                file_list = response.get('files', [])
                if file_list:
                    zip_buffer = io.BytesIO()
                    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                        for file in file_list:
                            if file['name'].endswith("_graded.docx") and "_graded_graded" not in file['name']:
                                set_loading_cursor(True)
                                with st.spinner(f"ƒêang x·ª≠ l√Ω file {file['name']}..."):
                                    file_content = download_file_from_drive(service, file['id'])
                                set_loading_cursor(False)
                                if file_content:
                                    zip_file.writestr(file['name'], file_content)
                    zip_buffer.seek(0)
                    st.download_button(
                        label="T·∫£i t·∫•t c·∫£ k·∫øt qu·∫£ (ZIP)",
                        data=zip_buffer,
                        file_name="all_graded_essays.zip",
                        mime="application/zip",
                        key="download_all_graded"
                    )
                else:
                    st.info("Ch∆∞a c√≥ k·∫øt qu·∫£ ch·∫•m ƒëi·ªÉm n√†o ƒë∆∞·ª£c l∆∞u.")
            elif uploaded_essays and not st.session_state["start_grading"]:
                st.info("Vui l√≤ng ch·ªçn ƒë√°p √°n m·∫´u v√† nh·∫•n 'Ch·∫•m b√†i' ƒë·ªÉ b·∫Øt ƒë·∫ßu ch·∫•m ƒëi·ªÉm.")
            elif uploaded_essays:
                st.info("ƒêang x·ª≠ l√Ω b√†i l√†m...")

        with tab3:
            df = load_grading_report(service, reports_folder_id)
            if df is not None:
                st.subheader("B√°o c√°o ƒëi·ªÉm t·ªïng h·ª£p:")
                st.dataframe(df)
                csv_buffer = io.StringIO()
                df.to_csv(csv_buffer, index=False, encoding='utf-8-sig')
                csv = csv_buffer.getvalue().encode('utf-8')
                st.download_button(
                    label="T·∫£i b√°o c√°o t·ªïng h·ª£p CSV",
                    data=csv,
                    file_name="grading_report_total.csv",
                    mime="text/csv"
                )
            else:
                st.info("Ch∆∞a c√≥ b√°o c√°o n√†o ƒë∆∞·ª£c l∆∞u.")
    
    elif role == "student":
        response = service.files().list(q=f"'{root_folder_id}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false", spaces='drive').execute()
        teacher_folders = response.get('files', [])
        all_exams = []
        for teacher_folder in teacher_folders:
            username = teacher_folder['name'].replace("teacher_", "")
            exams_folder = find_file_in_folder(service, "exams", teacher_folder['id'])
            if exams_folder:
                exam_list = get_exam_list(service, exams_folder['id'])
                for exam in exam_list:
                    subject_code = exam.get("subject_code", "N/A")
                    term = exam.get("term", "N/A")
                    subject_name = exam.get("subject_name", "N/A")
                    display_name = f"{subject_code} - {term} - {subject_name} - {username}"
                    all_exams.append({
                        "display_name": display_name,
                        "exam_id": exam['exam_id'],
                        "secret_code": exam['secret_code']
                    })
        if all_exams:
            mssv = st.text_input("MSSV:", value=st.session_state["mssv"], key="mssv_input")
            full_name = st.text_input("H·ªç v√† T√™n:", value=st.session_state["full_name"], key="full_name_input")
            st.session_state["mssv"] = mssv
            st.session_state["full_name"] = full_name
            if st.session_state["mssv"] and st.session_state["full_name"]:
                selected_exam = st.selectbox("Ch·ªçn ƒë·ªÅ thi:", [exam["display_name"] for exam in all_exams])
                secret_code = st.text_input("Nh·∫≠p m√£ s·ªë b√≠ m·∫≠t:", type="password")
                if st.button("Xem ƒë·ªÅ thi"):
                    selected_exam_data = next(exam for exam in all_exams if exam["display_name"] == selected_exam)
                    if secret_code == selected_exam_data["secret_code"]:
                        st.session_state["selected_exam_id"] = selected_exam_data["exam_id"]
                        st.session_state["exam_access_granted"] = True
                        st.rerun()
                    else:
                        st.error("M√£ s·ªë b√≠ m·∫≠t kh√¥ng ƒë√∫ng. Vui l√≤ng th·ª≠ l·∫°i.")
                if st.session_state.get("exam_access_granted", False):
                    tab1, tab2 = st.tabs(["L√†m b√†i thi online", "N·ªôp b√†i"])
                    with tab1:
                        if not st.session_state["start_exam"]:
                            if st.button("L√†m b√†i"):
                                st.session_state["start_exam"] = True
                                st.session_state["current_num_questions"] = 1
                                st.rerun()
                        else:
                            st.subheader("ƒê·ªÅ thi:")
                            file_id = st.session_state["selected_exam_id"]
                            viewer_url = f"https://drive.google.com/viewerng/viewer?embedded=true&url=https://drive.google.com/uc?id={file_id}"
                            pdf_display = f'<iframe src="{viewer_url}" width="100%" height="600px" frameborder="0"></iframe>'
                            st.markdown(pdf_display, unsafe_allow_html=True)
                            st.info("N·∫øu ƒë·ªÅ thi kh√¥ng hi·ªÉn th·ªã, vui l√≤ng s·ª≠ d·ª•ng n√∫t 'T·∫£i ƒë·ªÅ thi (PDF) n·∫øu kh√¥ng xem ƒë∆∞·ª£c' ƒë·ªÉ t·∫£i file v·ªÅ v√† xem.")
                            set_loading_cursor(True)
                            with st.spinner("ƒêang t·∫£i ƒë·ªÅ thi..."):
                                exam_content = download_file_from_drive(service, file_id)
                            set_loading_cursor(False)
                            st.download_button(
                                label="T·∫£i ƒë·ªÅ thi (PDF) n·∫øu kh√¥ng xem ƒë∆∞·ª£c",
                                data=exam_content,
                                file_name="de_thi.pdf",
                                mime="application/pdf"
                            )
                            answers = []
                            for i in range(st.session_state["current_num_questions"]):
                                st.write(f"**C√¢u {i+1}**")
                                answer = st_quill(f"C√¢u {i+1}:", key=f"answer_{i}")
                                answers.append(answer)
                            col1, col2 = st.columns(2)
                            with col1:
                                if st.button("Th√™m c√¢u h·ªèi"):
                                    st.session_state["current_num_questions"] += 1
                                    st.rerun()
                            with col2:
                                if st.session_state["current_num_questions"] > 1:
                                    if st.button("Lo·∫°i c√¢u h·ªèi"):
                                        st.session_state["current_num_questions"] -= 1
                                        st.rerun()
                            if st.button("N·ªôp b√†i"):
                                student_text = "\n".join([f"C√¢u {i+1}:\n{answer}" for i, answer in enumerate(answers) if answer])
                                filename = f"{st.session_state['mssv']}_{st.session_state['full_name']}.docx"
                                doc = docx.Document()
                                doc.add_paragraph(student_text)
                                doc_buffer = io.BytesIO()
                                doc.save(doc_buffer)
                                doc_buffer.seek(0)
                                teacher_username = selected_exam.split(" - ")[-1]
                                teacher_folder = get_or_create_folder(service, f"teacher_{teacher_username}", root_folder_id)
                                essays_folder = get_or_create_folder(service, "essays", teacher_folder)
                                upload_file_to_drive(service, doc_buffer.getvalue(), filename, essays_folder)
                                st.success(f"B√†i l√†m ƒë√£ ƒë∆∞·ª£c l∆∞u tr√™n Google Drive v·ªõi t√™n: {filename}")
                                st.session_state["start_exam"] = False
                                st.session_state["current_num_questions"] = 1
                                st.session_state["exam_access_granted"] = False
                                st.rerun()
                    with tab2:
                        uploaded_essay = st.file_uploader("T·∫£i l√™n b√†i l√†m t·ª± lu·∫≠n", type=["docx"])
                        if uploaded_essay:
                            filename = f"{st.session_state['mssv']}_{st.session_state['full_name']}.docx"
                            essay_content = uploaded_essay.read()
                            teacher_username = selected_exam.split(" - ")[-1]
                            teacher_folder = get_or_create_folder(service, f"teacher_{teacher_username}", root_folder_id)
                            essays_folder = get_or_create_folder(service, "essays", teacher_folder)
                            upload_file_to_drive(service, essay_content, filename, essays_folder)
                            st.success(f"B√†i l√†m ƒë√£ ƒë∆∞·ª£c l∆∞u tr√™n Google Drive v·ªõi t√™n: {filename}")
        else:
            st.error("Kh√¥ng t√¨m th·∫•y ƒë·ªÅ thi n√†o. Vui l√≤ng li√™n h·ªá gi√°o vi√™n.")
